# 7.31 划水的一天

> 问问自己今天干了啥，没错，划水划了一整天，太现实了，我好难受啊。然后今天又是朱师傅不给我布置任务的一天

今天做的是Jarvis OJ的格式化字符串的一题，那就顺便看看原理的问题吧，毕竟实现起来还是挺简单的，但是基础知识不懂还是不可以的。

# 格式化字符串整理

> 突然想到之前已经整理过，等这一篇写完，就把上一篇给删了，毕竟我太菜了。

格式化字符串主要是出现在一些要用到格式化字符串的情况下，现在基本上主流语言都支持这个东西，主要给看语言编译器的情况，有的就会编译器自己把控，所以就不会出啥大问题。但是对于我们来说，主要就是C语言的问题，毕竟是做pwn的吗！

主要会出现这种问题的就是printf系列函数主要有

| 函数                      | 基本介绍                               |
| ------------------------- | -------------------------------------- |
| printf                    | 输出到 stdout                          |
| fprintf                   | 输出到指定 FILE 流                     |
| vprintf                   | 根据参数列表格式化输出到 stdout        |
| vfprintf                  | 根据参数列表格式化输出到指定 FILE 流   |
| sprintf                   | 输出到字符串                           |
| snprintf                  | 输出指定字节数到字符串                 |
| vsprintf                  | 根据参数列表格式化输出到字符串         |
| vsnprintf                 | 根据参数列表格式化输出指定字节到字符串 |
| setproctitle              | 设置 argv                              |
| syslog                    | 输出日志                               |
| err, verr, warn, vwarn 等 | ...                                    |

这里面就是一个c语言(或者其他坏习惯的)程序员的bug问题了，你想正常一个格式字符一定要对应一个变量啊，他就非得写出问题，也就没办法了，只能被人搞了。

主要危害有啥呢，任意地址读，任意地址写，所以很有可能和其他点来混合来一起出题，格式化字符串可以来个地址泄露啊之类的，也还是可以的。但是本次主要讲格式化字符串。

之后以printf为例会有一个这样子的模型

![](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/figure/printf.png)

这里面我们正常看到格式化字符串里面每一个 %啥都会对应着一个变量，但是程序员因为不小心少对应了一个 变量，我们就会很难受，因为输出莫名其妙多出了一个东西，这个就是读取栈里面的一个东西，给你输出出来了。

格式化字符串的基本格式是

```c
%[parameter][flags][field width][.precision][length]type
```

可以看看维基百科里面的格式化字符串，但是ctf wiki里面给了 几个值得注意的pattern中的对应选择需要重点关注

- parameter
  - n$，获取格式化字符串中的指定参数
- flag
- field width
  - 输出的最小宽度
- precision
  - 输出的最大长度
- length，输出的长度
  - hh，输出一个字节
  - h，输出一个双字节
- type
  - d/i，有符号整数
  - u，无符号整数
  - x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。
  - o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。
  - s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。
  - c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。
  - p， void * 型，输出对应变量的值。printf("%p",a) 用地址的格式打印变量 a 的值，printf("%p", &a) 打印变量 a 所在的地址。
  - n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。
  - %， '`%`'字面值，不接受任何 flags, width。

(上面摘自CTF WIKI)

反正大概就是这些内容，是关于那个百分号的东西，遇到百分号就能解析 后面的参数，就是内容对应内容，要是没有的话，就会拉栈里面的内容直接读取。反正就是会是这样的。

```c
printf("%s %d %u");
```

反正%后面没有提供任何参数，就是会在你给的参数里面提一个读取，之后要是给了不可访问地址，程序就直接瘫痪了。

原理基本就是这个样子。

下面就是讲利用，这个就比较的贴近实用了。

## 格式化字符串的利用

通常有两个方式

1. 使程序崩溃
2. 借格式读取栈上内容

## 如何使程序崩溃

这个是简单的，直接一堆```%s```打上去应该是可以的，毕竟简单暴力，而且很有效，让远程服务器的服务崩溃还是可以的。

## 如何泄露内存

这一块就很多内容了，总结一句就是 %08x一直撸，撸到你想要的地方为止，这样应该是最好理解的了。

* 可以泄露栈内存
  * 获取某个变量的值
  * 获取某个变量对应地址的内存
* 泄露任意地址内存
  * 利用GOT表得到libc函数地址，进而获取其他libc地址
  * 盲打

之后就是一个调试 的过程了，照着ctf的wiki调一遍也就大概能明白原理的。

之后后面就会遇到泄露任意地址内存

```c
addr%k$s
```

如何确定是第几个参数，可以通过%一顿搞反正就是泄露



然后后面就是覆盖，这个的话就是偏移 借位就好



大概格式化字符串也就这些，所以今天笔记就到这，明天做题补充题目记录。

## 引用

[CTF-WIKI:https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_exploit-zh/)

